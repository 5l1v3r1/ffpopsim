# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.6
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


"""
FFPopSim library for population genetics.

This library offers two simulation packages for population genetics. Each is controlled by a basic class:

- haploid_lowd: low-dimensional populations (genomes shorter than ~20 loci)
- haploid_clone:  high-dimensional simulations (genomes longer than ~20 loci)

The library is written in C++ and offers a Python interface. A simple evolution routine could be the following:

#####################################
#   EXAMPLE SCRIPT                  #
#####################################
import numpy as np
import matplotlib.pyplot as plt
import FFPopSim as h

c = h.haploid_lowd(4)
c.set_allele_frequencies([0,0.3,0.6,0.9], N=1000) 
c.evolve(10)
c.plot_fitness_histogram()
plt.show()
#####################################

which evolves a 4-loci population for 10 generations starting from fixed allele frequencies, and plots the
fitness histogram afterwards. Please look into the 'tests' folder for more usage examples. 

Requirements:
- numerical Python is used extensively in this library, and is *strongly* recommended for all users. We suggest to import numpy explicitely before using the library (but it will work in any case).
- matplotlib is used in the plot functions. As long as you do not call those, you can live without it. However, we suggest to import it explicitely before using the library.

*Note*: the Python interface does not offer the full functionality of the underlying library, nor as much
flexibility. If you need to perform a peculiar type of simulations that is not accessible by this Python
interface, consider C++ (or Python) subclassing.

"""


from sys import version_info
if version_info >= (3,0,0):
    new_instancemethod = lambda func, inst, cls: _FFPopSim.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_FFPopSim', [dirname(__file__)])
        except ImportError:
            import _FFPopSim
            return _FFPopSim
        if fp is not None:
            try:
                _mod = imp.load_module('_FFPopSim', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _FFPopSim = swig_import_helper()
    del swig_import_helper
else:
    import _FFPopSim
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class index_value_pair(object):
    """Proxy of C++ index_value_pair_t class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    index = _swig_property(_FFPopSim.index_value_pair_index_get, _FFPopSim.index_value_pair_index_set)
    val = _swig_property(_FFPopSim.index_value_pair_val_get, _FFPopSim.index_value_pair_val_set)
    def __init__(self, index_in=0, val_in=0): 
        """__init__(index_value_pair_t self, int index_in=0, double val_in=0) -> index_value_pair"""
        _FFPopSim.index_value_pair_swiginit(self,_FFPopSim.new_index_value_pair(index_in, val_in))
    def __str__(self):
        """__str__(index_value_pair self) -> char const *"""
        return _FFPopSim.index_value_pair___str__(self)

    def __repr__(self):
        """__repr__(index_value_pair self) -> char const *"""
        return _FFPopSim.index_value_pair___repr__(self)

    __swig_destroy__ = _FFPopSim.delete_index_value_pair
index_value_pair.__str__ = new_instancemethod(_FFPopSim.index_value_pair___str__,None,index_value_pair)
index_value_pair.__repr__ = new_instancemethod(_FFPopSim.index_value_pair___repr__,None,index_value_pair)
index_value_pair_swigregister = _FFPopSim.index_value_pair_swigregister
index_value_pair_swigregister(index_value_pair)

class genotype_value_pair(object):
    """Proxy of C++ genotype_value_pair_t class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    val = _swig_property(_FFPopSim.genotype_value_pair_val_get, _FFPopSim.genotype_value_pair_val_set)
    def __init__(self, *args, **kwargs): 
        """__init__(genotype_value_pair_t self, boost::dynamic_bitset< > genotype_in=boost::dynamic_bitset< >(0), double val_in=0) -> genotype_value_pair"""
        _FFPopSim.genotype_value_pair_swiginit(self,_FFPopSim.new_genotype_value_pair(*args, **kwargs))
    def __str__(self):
        """__str__(genotype_value_pair self) -> char const *"""
        return _FFPopSim.genotype_value_pair___str__(self)

    def __repr__(self):
        """__repr__(genotype_value_pair self) -> char const *"""
        return _FFPopSim.genotype_value_pair___repr__(self)

    def _get_genotype_length(self):
        """_get_genotype_length(genotype_value_pair self) -> int"""
        return _FFPopSim.genotype_value_pair__get_genotype_length(self)

    def _get_genotype(self, *args, **kwargs):
        """_get_genotype(genotype_value_pair self, int DIM1)"""
        return _FFPopSim.genotype_value_pair__get_genotype(self, *args, **kwargs)

    def _set_genotype(self, *args, **kwargs):
        """_set_genotype(genotype_value_pair self, boost::dynamic_bitset< > genotype_in)"""
        return _FFPopSim.genotype_value_pair__set_genotype(self, *args, **kwargs)

    @property
    def genotype(self):
            import numpy as np
            return np.array(self._get_genotype(self._get_genotype_length()), bool)


    @genotype.setter
    def genotype(self, genotype):
            self._set_genotype(genotype)

    __swig_destroy__ = _FFPopSim.delete_genotype_value_pair
genotype_value_pair.__str__ = new_instancemethod(_FFPopSim.genotype_value_pair___str__,None,genotype_value_pair)
genotype_value_pair.__repr__ = new_instancemethod(_FFPopSim.genotype_value_pair___repr__,None,genotype_value_pair)
genotype_value_pair._get_genotype_length = new_instancemethod(_FFPopSim.genotype_value_pair__get_genotype_length,None,genotype_value_pair)
genotype_value_pair._get_genotype = new_instancemethod(_FFPopSim.genotype_value_pair__get_genotype,None,genotype_value_pair)
genotype_value_pair._set_genotype = new_instancemethod(_FFPopSim.genotype_value_pair__set_genotype,None,genotype_value_pair)
genotype_value_pair_swigregister = _FFPopSim.genotype_value_pair_swigregister
genotype_value_pair_swigregister(genotype_value_pair)

class stat(object):
    """Proxy of C++ stat_t class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    mean = _swig_property(_FFPopSim.stat_mean_get, _FFPopSim.stat_mean_set)
    variance = _swig_property(_FFPopSim.stat_variance_get, _FFPopSim.stat_variance_set)
    def __init__(self, mean_in=0, variance_in=0): 
        """__init__(stat_t self, double mean_in=0, double variance_in=0) -> stat"""
        _FFPopSim.stat_swiginit(self,_FFPopSim.new_stat(mean_in, variance_in))
    def __str__(self):
        """__str__(stat self) -> char const *"""
        return _FFPopSim.stat___str__(self)

    def __repr__(self):
        """__repr__(stat self) -> char const *"""
        return _FFPopSim.stat___repr__(self)

    __swig_destroy__ = _FFPopSim.delete_stat
stat.__str__ = new_instancemethod(_FFPopSim.stat___str__,None,stat)
stat.__repr__ = new_instancemethod(_FFPopSim.stat___repr__,None,stat)
stat_swigregister = _FFPopSim.stat_swigregister
stat_swigregister(stat)

def binarify(gt, L=0):
    '''Transform an integer into a binary sequence on the L hypercube.'''
    import numpy as np
    if not L:
        L=1
        while gt > ((1<<L) - 1):
            L += 1
    return np.array(map(lambda l: bool(gt&(1<<(L-l-1))),range(L)))


def integerify(b):
    '''Transform a binary sequence on the HC into an integer.'''
    import numpy as np
    L = len(b)
    a = [(1<<(L-l-1)) for l in xrange(L)]
    return np.dot(b,a)

HC_MEMERR = _FFPopSim.HC_MEMERR
HC_BADARG = _FFPopSim.HC_BADARG
HC_VERBOSE = _FFPopSim.HC_VERBOSE
HC_FUNC = _FFPopSim.HC_FUNC
HC_COEFF = _FFPopSim.HC_COEFF
HC_FUNC_EQ_COEFF = _FFPopSim.HC_FUNC_EQ_COEFF
HG_VERBOSE = _FFPopSim.HG_VERBOSE
HG_LONGTIMEGEN = _FFPopSim.HG_LONGTIMEGEN
HG_CONTINUOUS = _FFPopSim.HG_CONTINUOUS
HG_NOTHING = _FFPopSim.HG_NOTHING
HG_EXTINCT = _FFPopSim.HG_EXTINCT
HG_BADARG = _FFPopSim.HG_BADARG
HG_MEMERR = _FFPopSim.HG_MEMERR
class haploid_lowd(object):
    """
    Class for low-dimensional population genetics (short genomes ~20 loci).

    This class is the main object for simulating the evolution of populations with
    a few loci (less than ~20). The class offers a number of functions, but an
    example will explain the basic idea:

    #####################################
    #   EXAMPLE SCRIPT                  #
    #####################################
    import numpy as np
    import matplotlib.pyplot as plt
    import FFPopSim as h

    c = h.haploid_lowd(5)
    c.set_genotypes([0, 2], [300, 700]) 
    c.set_fitness_additive([0.02,0.03,0.04,0.02, -0.03])
    c.evolve(10)
    c.plot_diversity_histogram()
    plt.show()
    #####################################

    An effective way to discover all available methods is to import FFPopSim from
    an interactive shell (e.g. iPython), create a population as above, and use TAB
    autocompletion:

    In [1]: import FFPopSim as h
    In [2]: c = h.haploid_lowd(5, 2000)
    In [3]: c.      <--- TAB

    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, L=1, rng_seed=0): 
        """
        Construct a low-dimensional population with certain parameters.

        Parameters:
        - L : number of loci (at least 1)
        - rng_seed : seed for the random number generator    

        """
        _FFPopSim.haploid_lowd_swiginit(self,_FFPopSim.new_haploid_lowd(L, rng_seed))
    __swig_destroy__ = _FFPopSim.delete_haploid_lowd
    carrying_capacity = _swig_property(_FFPopSim.haploid_lowd_carrying_capacity_get, _FFPopSim.haploid_lowd_carrying_capacity_set)
    outcrossing_rate = _swig_property(_FFPopSim.haploid_lowd_outcrossing_rate_get, _FFPopSim.haploid_lowd_outcrossing_rate_set)
    free_recombination = _swig_property(_FFPopSim.haploid_lowd_free_recombination_get, _FFPopSim.haploid_lowd_free_recombination_set)
    circular = _swig_property(_FFPopSim.haploid_lowd_circular_get, _FFPopSim.haploid_lowd_circular_set)
    def _get_number_of_loci(self):
        """_get_number_of_loci(haploid_lowd self) -> int"""
        return _FFPopSim.haploid_lowd__get_number_of_loci(self)

    def _get_population_size(self):
        """_get_population_size(haploid_lowd self) -> double"""
        return _FFPopSim.haploid_lowd__get_population_size(self)

    def _get_generation(self):
        """_get_generation(haploid_lowd self) -> double"""
        return _FFPopSim.haploid_lowd__get_generation(self)

    def _get_mutation_rate(self, *args, **kwargs):
        """_get_mutation_rate(haploid_lowd self, int locus, int direction) -> double"""
        return _FFPopSim.haploid_lowd__get_mutation_rate(self, *args, **kwargs)

    def set_wildtype(self, *args, **kwargs):
        """set_wildtype(haploid_lowd self, unsigned long N) -> int"""
        return _FFPopSim.haploid_lowd_set_wildtype(self, *args, **kwargs)

    def set_recombination_rates(self, *args, **kwargs):
        """set_recombination_rates(haploid_lowd self, double * rec_rates) -> int"""
        return _FFPopSim.haploid_lowd_set_recombination_rates(self, *args, **kwargs)

    def evolve(self, gen=1):
        """evolve(haploid_lowd self, int gen=1) -> int"""
        return _FFPopSim.haploid_lowd_evolve(self, gen)

    def evolve_norec(self, gen=1):
        """evolve_norec(haploid_lowd self, int gen=1) -> int"""
        return _FFPopSim.haploid_lowd_evolve_norec(self, gen)

    def evolve_deterministic(self, gen=1):
        """evolve_deterministic(haploid_lowd self, int gen=1) -> int"""
        return _FFPopSim.haploid_lowd_evolve_deterministic(self, gen)

    def get_genotype_frequency(self, *args, **kwargs):
        """get_genotype_frequency(haploid_lowd self, int gt) -> double"""
        return _FFPopSim.haploid_lowd_get_genotype_frequency(self, *args, **kwargs)

    def get_allele_frequency(self, *args, **kwargs):
        """get_allele_frequency(haploid_lowd self, int locus) -> double"""
        return _FFPopSim.haploid_lowd_get_allele_frequency(self, *args, **kwargs)

    def get_chi(self, *args, **kwargs):
        """get_chi(haploid_lowd self, int locus) -> double"""
        return _FFPopSim.haploid_lowd_get_chi(self, *args, **kwargs)

    def get_moment(self, *args, **kwargs):
        """get_moment(haploid_lowd self, int locus1, int locus2) -> double"""
        return _FFPopSim.haploid_lowd_get_moment(self, *args, **kwargs)

    def get_LD(self, *args, **kwargs):
        """get_LD(haploid_lowd self, int locus1, int locus2) -> double"""
        return _FFPopSim.haploid_lowd_get_LD(self, *args, **kwargs)

    def genotype_entropy(self):
        """genotype_entropy(haploid_lowd self) -> double"""
        return _FFPopSim.haploid_lowd_genotype_entropy(self)

    def allele_entropy(self):
        """allele_entropy(haploid_lowd self) -> double"""
        return _FFPopSim.haploid_lowd_allele_entropy(self)

    def get_fitness(self, *args, **kwargs):
        """get_fitness(haploid_lowd self, int n) -> double"""
        return _FFPopSim.haploid_lowd_get_fitness(self, *args, **kwargs)

    def get_fitness_statistics(self):
        """get_fitness_statistics(haploid_lowd self) -> stat"""
        return _FFPopSim.haploid_lowd_get_fitness_statistics(self)

    def select(self):
        """select(haploid_lowd self) -> int"""
        return _FFPopSim.haploid_lowd_select(self)

    def mutate(self):
        """mutate(haploid_lowd self) -> int"""
        return _FFPopSim.haploid_lowd_mutate(self)

    def recombine(self):
        """recombine(haploid_lowd self) -> int"""
        return _FFPopSim.haploid_lowd_recombine(self)

    def resample(self):
        """resample(haploid_lowd self) -> int"""
        return _FFPopSim.haploid_lowd_resample(self)

    def __str__(self):
        """__str__(haploid_lowd self) -> char const *"""
        return _FFPopSim.haploid_lowd___str__(self)

    def __repr__(self):
        """__repr__(haploid_lowd self) -> char const *"""
        return _FFPopSim.haploid_lowd___repr__(self)

    L = property(_get_number_of_loci)
    N = property(_get_population_size)
    number_of_loci = property(_get_number_of_loci)
    population_size = property(_get_population_size)
    generation = property(_get_generation)

    def _set_allele_frequencies(self, *args, **kwargs):
        """_set_allele_frequencies(haploid_lowd self, int DIM1, unsigned long N) -> int"""
        return _FFPopSim.haploid_lowd__set_allele_frequencies(self, *args, **kwargs)

    def set_allele_frequencies(self, frequencies, N=1000):
        '''Initialize the population in linkage equilibrium with allele frequencies.

        Parameters:
        - frequencies: an array of length L with all allele frequencies
        - N: the carrying capacity (target population size)

        *Note*: the latter parameter is only used for resampling and has therefore
        no crucial effect on the speed of the simulation.
        '''
        if len(frequencies) != self.L:
            raise ValueError('The input array of allele frequencies has the wrong length.')
        if self._set_allele_frequencies(frequencies, N):
            raise RuntimeError('Error in the C++ function.')

    def _set_genotypes(self, *args, **kwargs):
        """_set_genotypes(haploid_lowd self, int len1, int len2) -> int"""
        return _FFPopSim.haploid_lowd__set_genotypes(self, *args, **kwargs)

    def set_genotypes(self, indices, counts):
        '''Initialize population with fixed counts for specific genotypes.

        Parameters:
        - indices: list of genotypes to set (e.g. 0 --> 00...0, L-1 --> 11...1)
        - counts: list of counts for those genotypes

        *Note*: the population size and the carrying capacity are set as the sum of the counts.
        *Note*: you can use Python binary notation for the indices, e.g. 0b0110 is 6.
        '''
        import numpy as np
        indices = np.asarray(indices, float)
        counts = np.asarray(counts, float)
        if len(indices) != len(counts):
            raise ValueError('Indices and counts must have the same length')
        if self._set_genotypes(indices, counts):
            raise RuntimeError('Error in the C++ function.')

    def get_mutation_rate(self, locus=None, direction=None):
        '''Get one or several mutation rates.

        Parameters:
        - locus: get only the mutation rate(s) of this locus
        - direction: get only the forward or backward mutation rate(s)

        Returns:
        - the mutation rate(s) requensted

        *Note*: if the mutation rates for all loci and/or directions are the same,
        this function will try to be smart and give you the answer you are looking for.
        In case of doubt, you will get a matrix (L x 2) with the full mutation rate
        landscape.
        '''

        import numpy as np
        if locus is not None:
            if not np.isscalar(locus):
                raise TypeError('Please select a *single* locus or no locus at all.')
            if direction is not None:
                return self._get_mutation_rate(locus, direction)
            else:
                mrs = tuple([self._get_mutation_rate(locus, d) for d in [0,1]])
                if mrs[0] == mrs[1]:
                    return mrs[0]
                else:
                    return mrs
        else:
            if direction is not None:
                mrs = np.array([self._get_mutation_rate(l, direction) for l in xrange(self.L)])
                if len(np.unique(mrs)) == 1:
                    return mrs[0]
                else:
                    return mrs
            else:
                mrs = np.array([[self._get_mutation_rate(l, d) for l in xrange(self.L)] for d in [0,1]])
                if len(np.unique(mrs)) == 1:
                    return mrs[0,0]
                else:
                    return mrs

    def _set_mutation_rate(self, *args, **kwargs):
        """_set_mutation_rate(haploid_lowd self, double * IN_ARRAY2) -> int"""
        return _FFPopSim.haploid_lowd__set_mutation_rate(self, *args, **kwargs)

    def set_mutation_rate(self, rates, rates_back=None):
        '''Set the mutation rate.

        Parameters:
        - rates: if a double, the mutation rate at any locus in both directions
             or, if rates_back is not None, only in the forward direction
             if a vector, the mutation rate is specified for each locus, the same
             in both directions or, if rates_back is not None, only in the
             forward direction
        - rates_back: mutation rate in the backward direction (global or
             locus-specific)
        '''

        import numpy as np
        L = self.L
        if np.isscalar(rates):
            if rates_back is None:
                ratesm = np.repeat(rates, L * 2).reshape(2,L)
            else:
                ratesm = np.vstack([np.repeat(rates, L), np.repeat(rates_back, L)])
        elif (np.rank(rates) != 1) or ((rates_back is not None) and (np.rank(rates_back) != 1)):
            raise ValueError('Please input one/two numbers or arrays.')
        else:
            if rates_back is None:
                ratesm = np.vstack([rates, rates])
            else:
                ratesm = np.vstack([rates, rates_back])

        if self._set_mutation_rate(ratesm):
            raise RuntimeError('Error in the C++ function.')

    def get_genotype_frequencies(self):
        '''Get the frequency of each genotype.'''
        import numpy as np
        return np.array([self.get_genotype_frequency(l) for l in xrange(1<<self.L)])

    def get_allele_frequencies(self):
        '''Get all allele frequencies'''
        import numpy as np
        return np.array([self.get_allele_frequency(l) for l in xrange(self.L)])

    def random_clones(self, n_sample):
        '''Get random clones according to their frequencies.'''
        import numpy as np
        counts = np.random.multinomial(n_sample, self.get_genotype_frequencies())
        ind = counts.nonzero()[0]
        counts = counts[ind]
        sample = np.concatenate([np.repeat(ind[i], counts[i]) for i in xrange(len(ind))])
        np.random.shuffle(sample)
        return sample

    def _get_fitnesses(self, *args, **kwargs):
        """_get_fitnesses(haploid_lowd self, int DIM1)"""
        return _FFPopSim.haploid_lowd__get_fitnesses(self, *args, **kwargs)

    def get_fitnesses(self):
        '''Get the fitness of all possible genotypes.'''
        return self._get_fitnesses(1<<self.L)

    def get_fitness_histogram(self, n_sample=1000, **kwargs):
        '''Get the histogram of the fitness in the population.'''
        import numpy as np

        
        gt = self.random_clones(n_sample)

        
        fit = np.array([self.get_fitness(gt[i]) for i in xrange(n_sample)])

        return np.histogram(fit, bins=bins, **kwargs)


    def plot_fitness_histogram(self, axis=None, n_sample=1000, **kwargs):
        '''Plot the histogram of the fitness in the population.'''
        import numpy as np
        import matplotlib.pyplot as plt

        
        gt = self.random_clones(n_sample)

        
        fit = np.array([self.get_fitness(gt[i]) for i in xrange(n_sample)])

        
        if axis is None:
            fig = plt.figure()
            axis = fig.add_subplot(111)
            axis.set_title('Fitness histogram')
            axis.set_xlabel('Fitness')
        axis.hist(fit, **kwargs)


    def get_divergence_statistics(self, n_sample=1000):
        '''Get the mean and variance of the divergence in the population.'''
        import numpy as np
        L = self.L

        
        gt = self.random_clones(n_sample)

        
        div = np.array([binarify(gt[i], L).sum() for i in xrange(n_sample)], int)

        return stat(div.mean(), div.var())


    def get_divergence_histogram(self, bins=10, n_sample=1000, **kwargs):
        '''Get the histogram of the divergence in the population.'''
        import numpy as np
        L = self.L

        
        gt = self.random_clones(n_sample)

        
        div = np.array([binarify(gt[i], L).sum() for i in xrange(n_sample)], int)

        return np.histogram(div, bins=bins, **kwargs)


    def plot_divergence_histogram(self, axis=None, n_sample=1000, **kwargs):
        '''Plot the histogram of the divergence in the population.'''
        import numpy as np
        import matplotlib.pyplot as plt
        L = self.L

        
        gt = self.random_clones(n_sample)

        
        div = np.array([binarify(gt[i], L).sum() for i in xrange(n_sample)], int)

        
        if axis is None:
            fig = plt.figure()
            axis = fig.add_subplot(111)
            axis.set_title('Divergence histogram')
            axis.set_xlabel('Divergence')
        
        if 'bins' not in kwargs:
            kwargs['bins'] = np.arange(10) * max(1, (div.max() + 1 - div.min()) / 10) + div.min()
        axis.hist(div, **kwargs)


    def get_diversity_statistics(self, n_sample=1000):
        '''Get the mean and variance of the diversity in the population.'''
        import numpy as np
        L = self.L

        
        gt1 = self.random_clones(n_sample)
        gt2 = self.random_clones(n_sample)

        
        div = np.array([binarify(gt1[i] ^ gt2[i], L).sum() for i in xrange(n_sample)], int)

        return stat(div.mean(), div.var())


    def get_diversity_histogram(self, bins=10, n_sample=1000, **kwargs):
        '''Get the histogram of the diversity in the population.'''
        import numpy as np
        L = self.L

        
        gt1 = self.random_clones(n_sample)
        gt2 = self.random_clones(n_sample)

        
        div = np.array([binarify(gt1[i] ^ gt2[i], L).sum() for i in xrange(n_sample)], int)

        
        return np.histogram(div, bins=bins, **kwargs)


    def plot_diversity_histogram(self, axis=None, n_sample=1000, **kwargs):
        '''Plot the histogram of the diversity in the population.'''
        import numpy as np
        import matplotlib.pyplot as plt
        L = self.L

        
        gt1 = self.random_clones(n_sample)
        gt2 = self.random_clones(n_sample)

        
        div = np.array([binarify(gt1[i] ^ gt2[i], L).sum() for i in xrange(n_sample)], int)

        
        if axis is None:
            fig = plt.figure()
            axis = fig.add_subplot(111)
            axis.set_title('Diversity histogram')
            axis.set_xlabel('Diversity')
        
        if 'bins' not in kwargs:
            kwargs['bins'] = np.arange(10) * max(1, (div.max() + 1 - div.min()) / 10) + div.min()
        axis.hist(div, **kwargs)

    def _set_fitness_func(self, *args, **kwargs):
        """_set_fitness_func(haploid_lowd self, int len1, int len2) -> int"""
        return _FFPopSim.haploid_lowd__set_fitness_func(self, *args, **kwargs)

    def set_fitness_function(self, indices, vals):
        '''Set the fitness landscape at single points.

        Parameters:
        - indices: genotype to which the fitness values will be assigned
        - vals: fitness values to assign
        '''
        import numpy as np
        indices = np.asarray(indices, float)
        vals = np.asarray(vals, float)
        if len(indices) != len(vals):
            raise ValueError('Indices and values must have the same length')
        if self._set_fitness_func(indices, vals):
            raise RuntimeError('Error in the C++ function.')

    def set_fitness_additive(self, *args, **kwargs):
        """set_fitness_additive(haploid_lowd self, int DIM1)"""
        return _FFPopSim.haploid_lowd_set_fitness_additive(self, *args, **kwargs)

haploid_lowd._get_number_of_loci = new_instancemethod(_FFPopSim.haploid_lowd__get_number_of_loci,None,haploid_lowd)
haploid_lowd._get_population_size = new_instancemethod(_FFPopSim.haploid_lowd__get_population_size,None,haploid_lowd)
haploid_lowd._get_generation = new_instancemethod(_FFPopSim.haploid_lowd__get_generation,None,haploid_lowd)
haploid_lowd._get_mutation_rate = new_instancemethod(_FFPopSim.haploid_lowd__get_mutation_rate,None,haploid_lowd)
haploid_lowd.set_wildtype = new_instancemethod(_FFPopSim.haploid_lowd_set_wildtype,None,haploid_lowd)
haploid_lowd.set_recombination_rates = new_instancemethod(_FFPopSim.haploid_lowd_set_recombination_rates,None,haploid_lowd)
haploid_lowd.evolve = new_instancemethod(_FFPopSim.haploid_lowd_evolve,None,haploid_lowd)
haploid_lowd.evolve_norec = new_instancemethod(_FFPopSim.haploid_lowd_evolve_norec,None,haploid_lowd)
haploid_lowd.evolve_deterministic = new_instancemethod(_FFPopSim.haploid_lowd_evolve_deterministic,None,haploid_lowd)
haploid_lowd.get_genotype_frequency = new_instancemethod(_FFPopSim.haploid_lowd_get_genotype_frequency,None,haploid_lowd)
haploid_lowd.get_allele_frequency = new_instancemethod(_FFPopSim.haploid_lowd_get_allele_frequency,None,haploid_lowd)
haploid_lowd.get_chi = new_instancemethod(_FFPopSim.haploid_lowd_get_chi,None,haploid_lowd)
haploid_lowd.get_moment = new_instancemethod(_FFPopSim.haploid_lowd_get_moment,None,haploid_lowd)
haploid_lowd.get_LD = new_instancemethod(_FFPopSim.haploid_lowd_get_LD,None,haploid_lowd)
haploid_lowd.genotype_entropy = new_instancemethod(_FFPopSim.haploid_lowd_genotype_entropy,None,haploid_lowd)
haploid_lowd.allele_entropy = new_instancemethod(_FFPopSim.haploid_lowd_allele_entropy,None,haploid_lowd)
haploid_lowd.get_fitness = new_instancemethod(_FFPopSim.haploid_lowd_get_fitness,None,haploid_lowd)
haploid_lowd.get_fitness_statistics = new_instancemethod(_FFPopSim.haploid_lowd_get_fitness_statistics,None,haploid_lowd)
haploid_lowd.select = new_instancemethod(_FFPopSim.haploid_lowd_select,None,haploid_lowd)
haploid_lowd.mutate = new_instancemethod(_FFPopSim.haploid_lowd_mutate,None,haploid_lowd)
haploid_lowd.recombine = new_instancemethod(_FFPopSim.haploid_lowd_recombine,None,haploid_lowd)
haploid_lowd.resample = new_instancemethod(_FFPopSim.haploid_lowd_resample,None,haploid_lowd)
haploid_lowd.__str__ = new_instancemethod(_FFPopSim.haploid_lowd___str__,None,haploid_lowd)
haploid_lowd.__repr__ = new_instancemethod(_FFPopSim.haploid_lowd___repr__,None,haploid_lowd)
haploid_lowd._set_allele_frequencies = new_instancemethod(_FFPopSim.haploid_lowd__set_allele_frequencies,None,haploid_lowd)
haploid_lowd._set_genotypes = new_instancemethod(_FFPopSim.haploid_lowd__set_genotypes,None,haploid_lowd)
haploid_lowd._set_mutation_rate = new_instancemethod(_FFPopSim.haploid_lowd__set_mutation_rate,None,haploid_lowd)
haploid_lowd._get_fitnesses = new_instancemethod(_FFPopSim.haploid_lowd__get_fitnesses,None,haploid_lowd)
haploid_lowd._set_fitness_func = new_instancemethod(_FFPopSim.haploid_lowd__set_fitness_func,None,haploid_lowd)
haploid_lowd.set_fitness_additive = new_instancemethod(_FFPopSim.haploid_lowd_set_fitness_additive,None,haploid_lowd)
haploid_lowd_swigregister = _FFPopSim.haploid_lowd_swigregister
haploid_lowd_swigregister(haploid_lowd)

HCF_MEMERR = _FFPopSim.HCF_MEMERR
HCF_BADARG = _FFPopSim.HCF_BADARG
HCF_VERBOSE = _FFPopSim.HCF_VERBOSE
HP_VERBOSE = _FFPopSim.HP_VERBOSE
NO_GENOTYPE = _FFPopSim.NO_GENOTYPE
HP_MINAF = _FFPopSim.HP_MINAF
MAX_DELTAFITNESS = _FFPopSim.MAX_DELTAFITNESS
MAX_POPSIZE = _FFPopSim.MAX_POPSIZE
HP_NOTHING = _FFPopSim.HP_NOTHING
HP_RANDOM_SAMPLE_FRAC = _FFPopSim.HP_RANDOM_SAMPLE_FRAC
FREE_RECOMBINATION = _FFPopSim.FREE_RECOMBINATION
CROSSOVERS = _FFPopSim.CROSSOVERS
HP_BADARG = _FFPopSim.HP_BADARG
HP_MEMERR = _FFPopSim.HP_MEMERR
HP_EXPLOSIONWARN = _FFPopSim.HP_EXPLOSIONWARN
HP_EXTINCTERR = _FFPopSim.HP_EXTINCTERR
HP_NOBINSERR = _FFPopSim.HP_NOBINSERR
HP_WRONGBINSERR = _FFPopSim.HP_WRONGBINSERR
class clone(object):
    """Proxy of C++ clone_t class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    _trait = _swig_property(_FFPopSim.clone__trait_get, _FFPopSim.clone__trait_set)
    fitness = _swig_property(_FFPopSim.clone_fitness_get, _FFPopSim.clone_fitness_set)
    clone_size = _swig_property(_FFPopSim.clone_clone_size_get, _FFPopSim.clone_clone_size_set)
    def __init__(self, n_traits=0): 
        """__init__(clone_t self, int n_traits=0) -> clone"""
        _FFPopSim.clone_swiginit(self,_FFPopSim.new_clone(n_traits))
    def __lt__(self, *args, **kwargs):
        """__lt__(clone self, clone other) -> bool"""
        return _FFPopSim.clone___lt__(self, *args, **kwargs)

    def __gt__(self, *args, **kwargs):
        """__gt__(clone self, clone other) -> bool"""
        return _FFPopSim.clone___gt__(self, *args, **kwargs)

    def __eq__(self, *args, **kwargs):
        """__eq__(clone self, clone other) -> bool"""
        return _FFPopSim.clone___eq__(self, *args, **kwargs)

    def __str__(self):
        """__str__(clone self) -> char const *"""
        return _FFPopSim.clone___str__(self)

    def __repr__(self):
        """__repr__(clone self) -> char const *"""
        return _FFPopSim.clone___repr__(self)

    def _get_number_of_traits(self):
        """_get_number_of_traits(clone self) -> int"""
        return _FFPopSim.clone__get_number_of_traits(self)

    def _get_trait(self, *args, **kwargs):
        """_get_trait(clone self, int DIM1)"""
        return _FFPopSim.clone__get_trait(self, *args, **kwargs)

    number_of_traits = property(_get_number_of_traits)
    @property
    def trait(self):
            return self._get_trait(self.number_of_traits)

    def _get_genotype_length(self):
        """_get_genotype_length(clone self) -> int"""
        return _FFPopSim.clone__get_genotype_length(self)

    def _get_genotype(self, *args, **kwargs):
        """_get_genotype(clone self, int DIM1)"""
        return _FFPopSim.clone__get_genotype(self, *args, **kwargs)

    def _set_genotype(self, *args, **kwargs):
        """_set_genotype(clone self, boost::dynamic_bitset< > genotype_in)"""
        return _FFPopSim.clone__set_genotype(self, *args, **kwargs)

    @property
    def genotype(self):
            import numpy as np
            return np.array(self._get_genotype(self._get_genotype_length()), bool)


    @genotype.setter
    def genotype(self, genotype):
            self._set_genotype(genotype)

    __swig_destroy__ = _FFPopSim.delete_clone
clone.__lt__ = new_instancemethod(_FFPopSim.clone___lt__,None,clone)
clone.__gt__ = new_instancemethod(_FFPopSim.clone___gt__,None,clone)
clone.__eq__ = new_instancemethod(_FFPopSim.clone___eq__,None,clone)
clone.__str__ = new_instancemethod(_FFPopSim.clone___str__,None,clone)
clone.__repr__ = new_instancemethod(_FFPopSim.clone___repr__,None,clone)
clone._get_number_of_traits = new_instancemethod(_FFPopSim.clone__get_number_of_traits,None,clone)
clone._get_trait = new_instancemethod(_FFPopSim.clone__get_trait,None,clone)
clone._get_genotype_length = new_instancemethod(_FFPopSim.clone__get_genotype_length,None,clone)
clone._get_genotype = new_instancemethod(_FFPopSim.clone__get_genotype,None,clone)
clone._set_genotype = new_instancemethod(_FFPopSim.clone__set_genotype,None,clone)
clone_swigregister = _FFPopSim.clone_swigregister
clone_swigregister(clone)

class haploid_highd(object):
    """
    Class for high-dimensional population genetics (genomes larger than ~20 loci).

    This class is the main object for simulating the evolution of populations with
    many loci (more than ~20). The class offers a number of functions, but an
    example will explain the basic idea:

    #####################################
    #   EXAMPLE SCRIPT                  #
    #####################################
    import numpy as np
    import matplotlib.pyplot as plt
    import FFPopSim as h

    c = h.haploid_highd(5000, 2000)
    c.set_genotypes() 
    c.mutation_rate = 0.01
    c.evolve(10)
    c.plot_divergence_histogram()
    plt.show()
    #####################################

    An effective way to discover all available methods is to import FFPopSim from
    an interactive shell (e.g. iPython), create a population as above, and use TAB
    autocompletion:

    In [1]: import FFPopSim as h
    In [2]: c = h.haploid_highd(5000, 2000)
    In [3]: c.      <--- TAB


    Populations can have a number of phenotypic traits that concur to the fitness
    of each individual. The function that calculates fitness from the phenotype is
    (TODO: should be) described by the user, as well as all the full genotype-
    phenotype map.

    *Note*: fitness is not a phenotypic trait directly, but rather a function of _all_
    phenotypic traits together. However, in case 

    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    trait = _swig_property(_FFPopSim.haploid_highd_trait_get, _FFPopSim.haploid_highd_trait_set)
    current_pop = _swig_property(_FFPopSim.haploid_highd_current_pop_get, _FFPopSim.haploid_highd_current_pop_set)
    new_pop = _swig_property(_FFPopSim.haploid_highd_new_pop_get, _FFPopSim.haploid_highd_new_pop_set)
    def __init__(self, L=0, rng_seed=0, number_of_traits=1): 
        """
        Construct a high-dimensional population with certain parameters.

        Parameters:
        - L     length of the genome(number of loci)
        - rng_seed      seed for the random generator. If zero (default) pick a random number
        - number_of_traits      number of phenotypic traits

        """
        _FFPopSim.haploid_highd_swiginit(self,_FFPopSim.new_haploid_highd(L, rng_seed, number_of_traits))
    __swig_destroy__ = _FFPopSim.delete_haploid_highd
    carrying_capacity = _swig_property(_FFPopSim.haploid_highd_carrying_capacity_get, _FFPopSim.haploid_highd_carrying_capacity_set)
    mutation_rate = _swig_property(_FFPopSim.haploid_highd_mutation_rate_get, _FFPopSim.haploid_highd_mutation_rate_set)
    outcrossing_rate = _swig_property(_FFPopSim.haploid_highd_outcrossing_rate_get, _FFPopSim.haploid_highd_outcrossing_rate_set)
    crossover_rate = _swig_property(_FFPopSim.haploid_highd_crossover_rate_get, _FFPopSim.haploid_highd_crossover_rate_set)
    recombination_model = _swig_property(_FFPopSim.haploid_highd_recombination_model_get, _FFPopSim.haploid_highd_recombination_model_set)
    circular = _swig_property(_FFPopSim.haploid_highd_circular_get, _FFPopSim.haploid_highd_circular_set)
    def _get_number_of_loci(self):
        """_get_number_of_loci(haploid_highd self) -> int"""
        return _FFPopSim.haploid_highd__get_number_of_loci(self)

    def _get_population_size(self):
        """_get_population_size(haploid_highd self) -> int"""
        return _FFPopSim.haploid_highd__get_population_size(self)

    def _get_generation(self):
        """_get_generation(haploid_highd self) -> int"""
        return _FFPopSim.haploid_highd__get_generation(self)

    def _get_number_of_clones(self):
        """_get_number_of_clones(haploid_highd self) -> int"""
        return _FFPopSim.haploid_highd__get_number_of_clones(self)

    def _get_number_of_traits(self):
        """_get_number_of_traits(haploid_highd self) -> int"""
        return _FFPopSim.haploid_highd__get_number_of_traits(self)

    def set_wildtype(self, *args, **kwargs):
        """set_wildtype(haploid_highd self, unsigned long N) -> int"""
        return _FFPopSim.haploid_highd_set_wildtype(self, *args, **kwargs)

    def add_genotypes(self, *args, **kwargs):
        """add_genotypes(haploid_highd self, boost::dynamic_bitset< > newgt, int n)"""
        return _FFPopSim.haploid_highd_add_genotypes(self, *args, **kwargs)

    def flip_single_locus(self, *args, **kwargs):
        """flip_single_locus(haploid_highd self, unsigned int clonenum, int locus)"""
        return _FFPopSim.haploid_highd_flip_single_locus(self, *args, **kwargs)

    def add_trait_coefficient(self, *args, **kwargs):
        """add_trait_coefficient(haploid_highd self, double value, vector< int > loci, int traitnumber=0) -> int"""
        return _FFPopSim.haploid_highd_add_trait_coefficient(self, *args, **kwargs)

    def clear_traits(self):
        """clear_traits(haploid_highd self)"""
        return _FFPopSim.haploid_highd_clear_traits(self)

    def add_fitness_coefficient(self, *args, **kwargs):
        """add_fitness_coefficient(haploid_highd self, double value, vector< int > loci) -> int"""
        return _FFPopSim.haploid_highd_add_fitness_coefficient(self, *args, **kwargs)

    def clear_fitness(self):
        """clear_fitness(haploid_highd self)"""
        return _FFPopSim.haploid_highd_clear_fitness(self)

    def _evolve(self, gen=1):
        """_evolve(haploid_highd self, int gen=1) -> int"""
        return _FFPopSim.haploid_highd__evolve(self, gen)

    def bottleneck(self, *args, **kwargs):
        """bottleneck(haploid_highd self, int size_of_bottleneck) -> int"""
        return _FFPopSim.haploid_highd_bottleneck(self, *args, **kwargs)

    def calc_stat(self):
        """calc_stat(haploid_highd self)"""
        return _FFPopSim.haploid_highd_calc_stat(self)

    def unique_clones(self):
        """unique_clones(haploid_highd self)"""
        return _FFPopSim.haploid_highd_unique_clones(self)

    def random_clone(self):
        """random_clone(haploid_highd self) -> int"""
        return _FFPopSim.haploid_highd_random_clone(self)

    def get_genotype_string(self, *args, **kwargs):
        """get_genotype_string(haploid_highd self, unsigned int i) -> string"""
        return _FFPopSim.haploid_highd_get_genotype_string(self, *args, **kwargs)

    def get_diversity_statistics(self, n_sample=1000):
        """get_diversity_statistics(haploid_highd self, unsigned int n_sample=1000) -> stat"""
        return _FFPopSim.haploid_highd_get_diversity_statistics(self, n_sample)

    def get_divergence_statistics(self, n_sample=1000):
        """get_divergence_statistics(haploid_highd self, unsigned int n_sample=1000) -> stat"""
        return _FFPopSim.haploid_highd_get_divergence_statistics(self, n_sample)

    def get_allele_frequency(self, *args, **kwargs):
        """get_allele_frequency(haploid_highd self, int l) -> double"""
        return _FFPopSim.haploid_highd_get_allele_frequency(self, *args, **kwargs)

    def get_pair_frequency(self, *args, **kwargs):
        """get_pair_frequency(haploid_highd self, int locus1, int locus2) -> double"""
        return _FFPopSim.haploid_highd_get_pair_frequency(self, *args, **kwargs)

    def get_pair_frequencies(self, *args, **kwargs):
        """get_pair_frequencies(haploid_highd self, vector< vector< int > > * loci) -> vector< double >"""
        return _FFPopSim.haploid_highd_get_pair_frequencies(self, *args, **kwargs)

    def get_chi(self, *args, **kwargs):
        """get_chi(haploid_highd self, int l) -> double"""
        return _FFPopSim.haploid_highd_get_chi(self, *args, **kwargs)

    def get_fitness(self, *args, **kwargs):
        """get_fitness(haploid_highd self, int n) -> double"""
        return _FFPopSim.haploid_highd_get_fitness(self, *args, **kwargs)

    def get_trait(self, *args, **kwargs):
        """get_trait(haploid_highd self, int n, int t=0) -> double"""
        return _FFPopSim.haploid_highd_get_trait(self, *args, **kwargs)

    def get_fitness_statistics(self):
        """get_fitness_statistics(haploid_highd self) -> stat"""
        return _FFPopSim.haploid_highd_get_fitness_statistics(self)

    def get_trait_statistics(self, t=0):
        """get_trait_statistics(haploid_highd self, int t=0) -> stat"""
        return _FFPopSim.haploid_highd_get_trait_statistics(self, t)

    def get_trait_covariance(self, *args, **kwargs):
        """get_trait_covariance(haploid_highd self, int t1, int t2) -> double"""
        return _FFPopSim.haploid_highd_get_trait_covariance(self, *args, **kwargs)

    def max_fitness(self):
        """max_fitness(haploid_highd self) -> double"""
        return _FFPopSim.haploid_highd_max_fitness(self)

    def print_allele_frequencies(self, *args, **kwargs):
        """print_allele_frequencies(haploid_highd self, ostream & out) -> int"""
        return _FFPopSim.haploid_highd_print_allele_frequencies(self, *args, **kwargs)

    def read_ms_sample(self, *args, **kwargs):
        """read_ms_sample(haploid_highd self, istream & gts, int skip_locus, int multiplicity) -> int"""
        return _FFPopSim.haploid_highd_read_ms_sample(self, *args, **kwargs)

    def read_ms_sample_sparse(self, *args, **kwargs):
        """read_ms_sample_sparse(haploid_highd self, istream & gts, int skip_locus, int multiplicity, int distance) -> int"""
        return _FFPopSim.haploid_highd_read_ms_sample_sparse(self, *args, **kwargs)

    def __str__(self):
        """__str__(haploid_highd self) -> char const *"""
        return _FFPopSim.haploid_highd___str__(self)

    def __repr__(self):
        """__repr__(haploid_highd self) -> char const *"""
        return _FFPopSim.haploid_highd___repr__(self)

    L = property(_get_number_of_loci)
    N = property(_get_population_size)
    number_of_loci = property(_get_number_of_loci)
    population_size = property(_get_population_size)
    generation = property(_get_generation)
    number_of_clones = property(_get_number_of_clones)
    number_of_traits = property(_get_number_of_traits)

    def _set_allele_frequencies(self, *args, **kwargs):
        """_set_allele_frequencies(haploid_highd self, double * IN_ARRAY1, int n_o_genotypes) -> int"""
        return _FFPopSim.haploid_highd__set_allele_frequencies(self, *args, **kwargs)

    def set_allele_frequencies(self, frequencies, N=1000):
        '''Initialize the population according to the given allele frequencies.

        Parameters:
        - frequencies: an array of length L with all allele frequencies
        - N: the carrying capacity (target population size)
        '''
        if len(frequencies) != self.L:
                raise ValueError('Please input an L dimensional list of allele frequencies.')
        if self._set_allele_frequencies(frequencies, N):
            raise RuntimeError('Error in the C++ function.')

    def _set_genotypes(self, *args, **kwargs):
        """_set_genotypes(haploid_highd self, int len1, int len2) -> int"""
        return _FFPopSim.haploid_highd__set_genotypes(self, *args, **kwargs)

    def set_genotypes(self, genotypes, counts):
        '''Initialize population with fixed counts for specific genotypes.

        Parameters:
        - indices: list of genotypes to set (e.g. 0 --> 00...0, L-1 --> 11...1)
        - counts: list of counts for those genotypes

        *Note*: the population size and the carrying capacity are set as the sum of the counts.
        *Note*: you can use Python binary notation for the indices, e.g. 0b0110 is 6.
        '''
        import numpy as np
        genotypes = np.array(genotypes, float, copy=False, ndmin=2)
        counts = np.asarray(counts, float)
        if len(genotypes) != len(counts):
            raise ValueError('Indices and counts must have the same length')
        if self._set_genotypes(genotypes.flatten(), counts):
            raise RuntimeError('Error in the C++ function.')

    def evolve(self, gen=1):
            '''Evolve for some generations.

            Parameters:
            - gen: number of generations
            '''

            if self._evolve(gen):
                    raise RuntimeError('Error in the C++ function.')
            else:
                    self.calc_stat()

    def _get_allele_frequencies(self, *args, **kwargs):
        """_get_allele_frequencies(haploid_highd self, double * ARGOUT_ARRAY1)"""
        return _FFPopSim.haploid_highd__get_allele_frequencies(self, *args, **kwargs)

    def get_allele_frequencies(self): return self._get_allele_frequencies(self.L)

    def get_genotype(self, *args, **kwargs):
        """get_genotype(haploid_highd self, unsigned int i, short * ARGOUT_ARRAY1)"""
        return _FFPopSim.haploid_highd_get_genotype(self, *args, **kwargs)

    def get_genotypes(self, ind=None):
            '''Get genotypes of the population.

            Parameters:
            - ind: if a scalar, a single genotype corresponding to clone ind is returned.
                   otherwise, several genotypes are returned (default: all)
            '''
            import numpy as np
            L = self.number_of_loci
            if np.isscalar(ind):
                    return np.array(self.get_genotype(ind, L), bool)

            if ind is None:
                    ind = xrange(self.number_of_clones)
            genotypes = np.zeros((len(ind), L), bool)
            for i, indi in enumerate(ind):
                    genotypes[i] = self.get_genotype(indi, L)
            return genotypes

    def clear_trait(self, *args, **kwargs):
        """clear_trait(haploid_highd self, unsigned int traitnumber)"""
        return _FFPopSim.haploid_highd_clear_trait(self, *args, **kwargs)

    def _get_additive_trait(self, *args, **kwargs):
        """_get_additive_trait(haploid_highd self, double * ARGOUT_ARRAY1, int traitnumber=0)"""
        return _FFPopSim.haploid_highd__get_additive_trait(self, *args, **kwargs)

    def get_additive_trait(self, traitnumber=0):
            '''Get an array with the additive part of a trait for all loci.'''
            return self._get_additive_trait(self.L, traitnumber)

    def set_additive_trait(self, *args, **kwargs):
        """set_additive_trait(haploid_highd self, int DIM1, int traitnumber=0)"""
        return _FFPopSim.haploid_highd_set_additive_trait(self, *args, **kwargs)

    def _get_fitnesses(self, *args, **kwargs):
        """_get_fitnesses(haploid_highd self, int DIM1)"""
        return _FFPopSim.haploid_highd__get_fitnesses(self, *args, **kwargs)

    def get_fitnesses(self):
            '''Get the fitness of all clones.'''
            return self._get_fitnesses(self.number_of_clones)

    def distance_Hamming(self, clone_gt1, clone_gt2, chunks=None, every=1):
            import numpy as np
            if np.isscalar(clone_gt1):
                    genotypes = self.get_genotypes((clone_gt1, clone_gt2))
                    clone_gt1 = genotypes[0]
                    clone_gt2 = genotypes[1]

            if chunks is not None:
                    ind = np.zeros(clones.shape[1], bool)
                    for chunk in chunks:
                            inde = np.arange(chunk[1] - chunk[0])
                            inde = inde[(inde % every) == 0] + chunk[0]
                            ind[inde] = True
                    clone_gt1 = clone_gt1[ind]
                    clone_gt2 = clone_gt2[ind]
            return (clone_gt1 != clone_gt2).sum()

    def random_genomes(self, n):
            import numpy as np
            L = self.number_of_loci
            genotypes = np.zeros((n, L), bool)
            for i in xrange(genotypes.shape[0]):
                    genotypes[i] = self.get_genotype(self.random_clone(), L)
            return genotypes

    def random_clones(self, *args, **kwargs):
        """random_clones(haploid_highd self, int DIM1)"""
        return _FFPopSim.haploid_highd_random_clones(self, *args, **kwargs)

    def get_fitness_histogram(self, bins=10, n_sample=1000, **kwargs):
            '''Calculate the fitness histogram.'''
            import numpy as np
            fit = [self.get_fitness(self.random_clone()) for i in xrange(n_sample)]
            h = np.histogram(fit, bins=bins, **kwargs)
            return h
        
        
    def plot_fitness_histogram(self, axis=None, **kwargs):
            '''Plot a distribution of fitness in the population.'''
            import matplotlib.pyplot as plt
            fit = self.get_fitnesses();
        
            if axis is None:
                    fig = plt.figure()
                    axis = fig.add_subplot(111)
                    axis.set_title('Fitness histogram')
                    axis.set_xlabel('Fitness')
            return axis.hist(fit, **kwargs)
        
        
    def get_divergence_histogram(self, bins=10, chunks=None, every=1, n_sample=1000, **kwargs):
            '''Get the divergence histogram restricted to those chunks of the genome.'''
            import numpy as np
        
            
            if chunks is not None:
                    chunks = np.asarray(chunks)
                    if (np.rank(chunks) != 2) or (chunks.shape[1] != 2):
                            raise ValueError('Please input an N x 2 matrix with the chunks initial and (final+1) positions')
        
            
            genotypes = self.random_genomes(n_sample)
        
            
            if chunks is not None:
                    ind = np.zeros(genotypes.shape[1], bool)
                    for chunk in chunks:
                            inde = np.arange(chunk[1] - chunk[0])
                            inde = inde[(inde % every) == 0] + chunk[0]
                            ind[inde] = True
                    genotypes = genotypes[:,ind]
        
            
            div = genotypes.sum(axis=1)
        
            
            return np.histogram(div, bins=bins, **kwargs)
        
        
    def plot_divergence_histogram(self, axis=None, n_sample=1000, **kwargs):
            '''Plot the divergence histogram.'''
            import matplotlib.pyplot as plt
            import numpy as np
            genotypes = self.random_genomes(n_sample)
            div = genotypes.sum(axis=1)
         
            if axis is None:
                    fig = plt.figure()
                    axis = fig.add_subplot(111)
                    axis.set_title('Divergence histogram')
                    axis.set_xlabel('Divergence')
        
            if 'bins' not in kwargs:
                    kwargs['bins'] = np.arange(10) * max(1, (div.max() + 1 - div.min()) / 10) + div.min()
            return axis.hist(div, **kwargs)
        
        
    def get_diversity_histogram(self, bins=10, chunks=None, every=1, n_sample=1000, **kwargs):
            '''Get the diversity histogram restricted to those chunks of the genome.'''
            import numpy as np
        
            
            if chunks is not None:
                    chunks = np.asarray(chunks)
                    if (np.rank(chunks) != 2) or (chunks.shape[1] != 2):
                            raise ValueError('Please input an N x 2 matrix with the chunks initial and (final+1) positions')
        
            
            genotypes = self.random_genomes(2 * n_sample)
        
            
            if chunks is not None:
                    ind = np.zeros(genotypes.shape[1], bool)
                    for chunk in chunks:
                            inde = np.arange(chunk[1] - chunk[0])
                            inde = inde[(inde % every) == 0] + chunk[0]
                            ind[inde] = True
                    genotypes = genotypes[:,ind]
        
            
            genotypes1 = genotypes[:genotypes.shape[0] / 2]
            genotypes2 = genotypes[-genotypes1.shape[0]:]
            div = (genotypes1 != genotypes2).sum(axis=1)
        
            
            return np.histogram(div, bins=bins, **kwargs)


    def plot_diversity_histogram(self, axis=None, n_sample=1000, **kwargs):
            '''Plot the diversity histogram.'''
            import matplotlib.pyplot as plt
            import numpy as np
            genotypes1 = self.random_genomes(n_sample)
            genotypes2 = self.random_genomes(n_sample)
            div = (genotypes1 != genotypes2).sum(axis=1)
        
            if axis is None:
                    fig = plt.figure()
                    axis = fig.add_subplot(111)
                    axis.set_title('Diversity histogram')
                    axis.set_xlabel('Diversity')
        
            if 'bins' not in kwargs:
                    kwargs['bins'] = np.arange(10) * max(1, (div.max() + 1 - div.min()) / 10) + div.min()
            return axis.hist(div, **kwargs)

haploid_highd._get_number_of_loci = new_instancemethod(_FFPopSim.haploid_highd__get_number_of_loci,None,haploid_highd)
haploid_highd._get_population_size = new_instancemethod(_FFPopSim.haploid_highd__get_population_size,None,haploid_highd)
haploid_highd._get_generation = new_instancemethod(_FFPopSim.haploid_highd__get_generation,None,haploid_highd)
haploid_highd._get_number_of_clones = new_instancemethod(_FFPopSim.haploid_highd__get_number_of_clones,None,haploid_highd)
haploid_highd._get_number_of_traits = new_instancemethod(_FFPopSim.haploid_highd__get_number_of_traits,None,haploid_highd)
haploid_highd.set_wildtype = new_instancemethod(_FFPopSim.haploid_highd_set_wildtype,None,haploid_highd)
haploid_highd.add_genotypes = new_instancemethod(_FFPopSim.haploid_highd_add_genotypes,None,haploid_highd)
haploid_highd.flip_single_locus = new_instancemethod(_FFPopSim.haploid_highd_flip_single_locus,None,haploid_highd)
haploid_highd.add_trait_coefficient = new_instancemethod(_FFPopSim.haploid_highd_add_trait_coefficient,None,haploid_highd)
haploid_highd.clear_traits = new_instancemethod(_FFPopSim.haploid_highd_clear_traits,None,haploid_highd)
haploid_highd.add_fitness_coefficient = new_instancemethod(_FFPopSim.haploid_highd_add_fitness_coefficient,None,haploid_highd)
haploid_highd.clear_fitness = new_instancemethod(_FFPopSim.haploid_highd_clear_fitness,None,haploid_highd)
haploid_highd._evolve = new_instancemethod(_FFPopSim.haploid_highd__evolve,None,haploid_highd)
haploid_highd.bottleneck = new_instancemethod(_FFPopSim.haploid_highd_bottleneck,None,haploid_highd)
haploid_highd.calc_stat = new_instancemethod(_FFPopSim.haploid_highd_calc_stat,None,haploid_highd)
haploid_highd.unique_clones = new_instancemethod(_FFPopSim.haploid_highd_unique_clones,None,haploid_highd)
haploid_highd.random_clone = new_instancemethod(_FFPopSim.haploid_highd_random_clone,None,haploid_highd)
haploid_highd.get_genotype_string = new_instancemethod(_FFPopSim.haploid_highd_get_genotype_string,None,haploid_highd)
haploid_highd.get_diversity_statistics = new_instancemethod(_FFPopSim.haploid_highd_get_diversity_statistics,None,haploid_highd)
haploid_highd.get_divergence_statistics = new_instancemethod(_FFPopSim.haploid_highd_get_divergence_statistics,None,haploid_highd)
haploid_highd.get_allele_frequency = new_instancemethod(_FFPopSim.haploid_highd_get_allele_frequency,None,haploid_highd)
haploid_highd.get_pair_frequency = new_instancemethod(_FFPopSim.haploid_highd_get_pair_frequency,None,haploid_highd)
haploid_highd.get_pair_frequencies = new_instancemethod(_FFPopSim.haploid_highd_get_pair_frequencies,None,haploid_highd)
haploid_highd.get_chi = new_instancemethod(_FFPopSim.haploid_highd_get_chi,None,haploid_highd)
haploid_highd.get_fitness = new_instancemethod(_FFPopSim.haploid_highd_get_fitness,None,haploid_highd)
haploid_highd.get_trait = new_instancemethod(_FFPopSim.haploid_highd_get_trait,None,haploid_highd)
haploid_highd.get_fitness_statistics = new_instancemethod(_FFPopSim.haploid_highd_get_fitness_statistics,None,haploid_highd)
haploid_highd.get_trait_statistics = new_instancemethod(_FFPopSim.haploid_highd_get_trait_statistics,None,haploid_highd)
haploid_highd.get_trait_covariance = new_instancemethod(_FFPopSim.haploid_highd_get_trait_covariance,None,haploid_highd)
haploid_highd.max_fitness = new_instancemethod(_FFPopSim.haploid_highd_max_fitness,None,haploid_highd)
haploid_highd.print_allele_frequencies = new_instancemethod(_FFPopSim.haploid_highd_print_allele_frequencies,None,haploid_highd)
haploid_highd.read_ms_sample = new_instancemethod(_FFPopSim.haploid_highd_read_ms_sample,None,haploid_highd)
haploid_highd.read_ms_sample_sparse = new_instancemethod(_FFPopSim.haploid_highd_read_ms_sample_sparse,None,haploid_highd)
haploid_highd.__str__ = new_instancemethod(_FFPopSim.haploid_highd___str__,None,haploid_highd)
haploid_highd.__repr__ = new_instancemethod(_FFPopSim.haploid_highd___repr__,None,haploid_highd)
haploid_highd._set_allele_frequencies = new_instancemethod(_FFPopSim.haploid_highd__set_allele_frequencies,None,haploid_highd)
haploid_highd._set_genotypes = new_instancemethod(_FFPopSim.haploid_highd__set_genotypes,None,haploid_highd)
haploid_highd._get_allele_frequencies = new_instancemethod(_FFPopSim.haploid_highd__get_allele_frequencies,None,haploid_highd)
haploid_highd.get_genotype = new_instancemethod(_FFPopSim.haploid_highd_get_genotype,None,haploid_highd)
haploid_highd.clear_trait = new_instancemethod(_FFPopSim.haploid_highd_clear_trait,None,haploid_highd)
haploid_highd._get_additive_trait = new_instancemethod(_FFPopSim.haploid_highd__get_additive_trait,None,haploid_highd)
haploid_highd.set_additive_trait = new_instancemethod(_FFPopSim.haploid_highd_set_additive_trait,None,haploid_highd)
haploid_highd._get_fitnesses = new_instancemethod(_FFPopSim.haploid_highd__get_fitnesses,None,haploid_highd)
haploid_highd.random_clones = new_instancemethod(_FFPopSim.haploid_highd_random_clones,None,haploid_highd)
haploid_highd_swigregister = _FFPopSim.haploid_highd_swigregister
haploid_highd_swigregister(haploid_highd)

HIVPOP_VERBOSE = _FFPopSim.HIVPOP_VERBOSE
HIVPOP_BADARG = _FFPopSim.HIVPOP_BADARG
NOTHING = _FFPopSim.NOTHING
HIVGENOME = _FFPopSim.HIVGENOME
ENV_START = _FFPopSim.ENV_START
ENV_END = _FFPopSim.ENV_END
class hivgene(object):
    """Structure for an HIV gene."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    start = _swig_property(_FFPopSim.hivgene_start_get, _FFPopSim.hivgene_start_set)
    end = _swig_property(_FFPopSim.hivgene_end_get, _FFPopSim.hivgene_end_set)
    def __init__(self, start_in=0, end_in=10000): 
        """Structure for an HIV gene."""
        _FFPopSim.hivgene_swiginit(self,_FFPopSim.new_hivgene(start_in, end_in))
    def __str__(self):
        """__str__(hivgene self) -> char const *"""
        return _FFPopSim.hivgene___str__(self)

    def __repr__(self):
        """__repr__(hivgene self) -> char const *"""
        return _FFPopSim.hivgene___repr__(self)

    __swig_destroy__ = _FFPopSim.delete_hivgene
hivgene.__str__ = new_instancemethod(_FFPopSim.hivgene___str__,None,hivgene)
hivgene.__repr__ = new_instancemethod(_FFPopSim.hivgene___repr__,None,hivgene)
hivgene_swigregister = _FFPopSim.hivgene_swigregister
hivgene_swigregister(hivgene)

class hivpopulation(haploid_highd):
    """
    Class for HIV population genetics (genome size = 10000).

    This class is the main object for simulating the evolution of HIV.
    The class offers a number of functions, but an example will explain the basic
    idea:

    #####################################
    #   EXAMPLE SCRIPT                  #
    #####################################
    import numpy as np
    import matplotlib.pyplot as plt
    import FFPopSim as h

    c = h.hivpopulation(2000)
    c.evolve(10)
    c.plot_divergence_histogram()
    plt.show()
    #####################################

    An effective way to discover all available methods is to import FFPopSim from
    an interactive shell (e.g. iPython), create a population as above, and use TAB
    autocompletion:

    In [1]: import FFPopSim as h
    In [2]: c = h.haploid_highd(5000, 2000)
    In [3]: c.      <--- TAB

    In addition to the haploid_highd class, this class offers functions for reading
    fitness and drug resistance landscapes from a text file, and to save genomes as
    plain text or in compressed numerical Python format.

    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, N=0, rng_seed=0, mutation_rate=3e-5, coinfection_rate=1e-2, crossover_rate=1e-3): 
        """
        Construct a HIV population with certain parameters.

        Parameters:
        - N     number of viral particles
        - rng_seed	seed for the random number generator. If this is 0, time(NULL)+getpid() is used.
        - mutation_rate	mutation rate in events / generation / site
        - coinfection_rate	probability of coinfection of the same cell by two viral particles in events / generation
        - crossover_rate	probability of template switching during coinfection in events / site

        Note: the genome length is 10000 (see HIVGENOME).

        """
        _FFPopSim.hivpopulation_swiginit(self,_FFPopSim.new_hivpopulation(N, rng_seed, mutation_rate, coinfection_rate, crossover_rate))
    __swig_destroy__ = _FFPopSim.delete_hivpopulation
    env = _swig_property(_FFPopSim.hivpopulation_env_get, _FFPopSim.hivpopulation_env_set)
    def _set_treatment(self, *args, **kwargs):
        """_set_treatment(hivpopulation self, double t)"""
        return _FFPopSim.hivpopulation__set_treatment(self, *args, **kwargs)

    def _get_treatment(self):
        """_get_treatment(hivpopulation self) -> double"""
        return _FFPopSim.hivpopulation__get_treatment(self)

    def read_replication_coefficients(self, *args, **kwargs):
        """read_replication_coefficients(hivpopulation self, istream & model) -> int"""
        return _FFPopSim.hivpopulation_read_replication_coefficients(self, *args, **kwargs)

    def read_resistance_coefficients(self, *args, **kwargs):
        """read_resistance_coefficients(hivpopulation self, istream & model) -> int"""
        return _FFPopSim.hivpopulation_read_resistance_coefficients(self, *args, **kwargs)

    def write_genotypes(self, *args, **kwargs):
        """write_genotypes(hivpopulation self, ostream & out_genotypes, int sample_size, string gt_label="", int start=0, int length=0) -> int"""
        return _FFPopSim.hivpopulation_write_genotypes(self, *args, **kwargs)

    treatment = property(_get_treatment, _set_treatment)

    def write_genotypes_compressed(self, filename, sample_size, gt_label='', start=0, length=0):
            '''Write genotypes into a compressed archive.'''
            import numpy as np 
            L = self.number_of_loci
            if length <= 0:
                    length = L - start
            d = {}
            for i in xrange(sample_size):
                    rcl = self.random_clone()
                    d['>'+str(i)+'_GT-'+gt_label+'_'+str(rcl)] = self.get_genotype(rcl,L)[start:start+length]
            np.savez_compressed(filename, **d)    

    def set_trait_landscape(self,
                            traitnumber=0,
                            lethal_fraction=0.05,
                            deleterious_fraction=0.8,
                            adaptive_fraction=0.01,
                            effect_size_lethal=0.8,
                            effect_size_deleterious=0.1,
                            effect_size_adaptive=0.01,
                            env_fraction=0.1,
                            effect_size_env=0.01,
                            number_epitopes=0,
                            epitope_strength=0.05,
                            number_valleys=0,
                            valley_strength=0.1,
                            ):
        '''Set HIV trait landscape according to some general parameters.'''

        import numpy as np
        from scipy import stats

        
        def add_epitope(strength=0.2):
            '''Note: we are in the +-1 basis.'''
            loci = random.sample(range(9),2)
            loci.sort()
            depression = - 0.05
            f1 = depression*0.25
            f2 = depression*0.25
            f12 = depression*0.25 - strength*0.5
            return loci, f1,f2,f12
         
        def add_valley(depth=0.1, height=0.01):
            '''Note: we are in the +-1 basis.'''
            f1 = height*0.25
            f2 = height*0.25
            f12 = height*0.25 + depth*0.5
            return (f1,f2,f12)

        
        L = self.L
        aL = np.arange(L)

        
        single_locus_effects=np.zeros(L)
        multi_locus_coefficients=[]
                
        
        first_codon_position = np.arange(0,L,3)
        second_codon_position = np.arange(1,L,3)
        
        
        
        onetwo_vector = (aL % 3) < 2
        random_numbers = np.random.random(L)
        adaptive_mutations = (random_numbers > (1 - adaptive_fraction)) & onetwo_vector
        lethal_mutations = (random_numbers < lethal_fraction) & onetwo_vector
        deleterious_mutations = (random_numbers > lethal_fraction) & (random_numbers < (lethal_fraction + deleterious_fraction)) & onetwo_vector
        
        
        adaptive_dis = stats.expon(scale=effect_size_adaptive)
        deleterious_dis = stats.expon(scale=effect_size_deleterious)
        single_locus_effects[np.where(adaptive_mutations)] += adaptive_dis.rvs(adaptive_mutations.sum())
        single_locus_effects[np.where(deleterious_mutations)] -= deleterious_dis.rvs(deleterious_mutations.sum())
        single_locus_effects[np.where(lethal_mutations)] -= effect_size_lethal
        
        
        env_position = (aL >= self.env.start) * (aL < self.env.end)
        env_mutations = (random_numbers>(1 - env_fraction)) & onetwo_vector & env_position
        env_dis = stats.expon(scale=effect_size_env)
        single_locus_effects[np.where(env_mutations)] += env_dis.rvs(env_mutations.sum())
            
        
        
        
        
        for vi in xrange(number_valleys):
            pos = np.random.random_integers(L/3-100)
            d = int(stats.expon(scale=10).rvs() +1)
            valley_dis=stats.expon(scale=valley_strength)
            valley_str = valley_dis.rvs()
            if number_valleys:
                print 'valley:', pos*3, valley_str
            (f1,f2,f12)=add_valley(valley_str)
            single_locus_effects[pos*3+1]+=f1
            single_locus_effects[(pos+d)*3+1]+=f2
            multi_locus_coefficients.append([[pos*3+1, (pos+d)*3+1], f12])
        
        
        for ei in xrange(number_epitopes):
            pos = np.random.random_integers(L/3-10)
            epi_dis=stats.expon(scale=epitope_strength)
            epi_strength = epi_dis.rvs()
            if number_epitopes:
                    print 'epitope', pos*3, epi_strength
            epi, f1,f2,f12=add_epitope(epi_strength)
            single_locus_effects[(pos+epi[0])*3+1]+=f1
            single_locus_effects[(pos+epi[1])*3+1]+=f2
            multi_locus_coefficients.append([[(pos+epi[0])*3+1, (pos+epi[1])*3+1], f12])
                    

        
        self.clear_trait(traitnumber)
        self.set_additive_trait(single_locus_effects, traitnumber)
        for mlc in multi_locus_coefficients:
            self.add_trait_coefficient(mlc[1], np.asarray(mlc[0], int), traitnumber)
        self.calc_stat()

    def get_additive_replication(self):
            '''Get the additive part of the replication lansdscape.'''
            return self.get_additive_trait(0)


    def get_additive_resistance(self):
            '''Get the additive part of the resistance lansdscape.'''
            return self.get_additive_trait(1)


    def set_additive_replication(self, single_locus_effects):
            '''Set the additive part of the replication lansdscape.'''
            self.set_additive_trait(single_locus_effects, 0)


    def set_additive_resistance(self, single_locus_effects):
            '''Set the additive part of the resistance lansdscape.'''
            self.set_additive_trait(single_locus_effects, 1)


    def set_replication_landscape(self, **kwargs):
            '''Set the phenotypic landscape for the replication capacity of HIV.
            
            Parameters:
            -  traitnumber=0
            -  lethal_fraction=0.05
            -  deleterious_fraction=0.8
            -  adaptive_fraction=0.01
            -  effect_size_lethal=0.8
            -  effect_size_deleterious=0.1
            -  effect_size_adaptive=0.01
            -  env_fraction=0.1
            -  effect_size_env=0.01
            -  number_epitopes=0
            -  epitope_strength=0.05
            -  number_valleys=0
            -  valley_strength=0.1
            '''
            kwargs['traitnumber']=0
            self.set_trait_landscape(**kwargs)


    def set_resistance_landscape(self, **kwargs):
            '''Set the phenotypic landscape for the drug resistance of HIV.
            
            Parameters:
            -  traitnumber=0
            -  lethal_fraction=0.05
            -  deleterious_fraction=0.8
            -  adaptive_fraction=0.01
            -  effect_size_lethal=0.8
            -  effect_size_deleterious=0.1
            -  effect_size_adaptive=0.01
            -  env_fraction=0.1
            -  effect_size_env=0.01
            -  number_epitopes=0
            -  epitope_strength=0.05
            -  number_valleys=0
            -  valley_strength=0.1 
            '''

            kwargs['traitnumber']=0
            self.set_trait_landscape(**kwargs)

hivpopulation._set_treatment = new_instancemethod(_FFPopSim.hivpopulation__set_treatment,None,hivpopulation)
hivpopulation._get_treatment = new_instancemethod(_FFPopSim.hivpopulation__get_treatment,None,hivpopulation)
hivpopulation.read_replication_coefficients = new_instancemethod(_FFPopSim.hivpopulation_read_replication_coefficients,None,hivpopulation)
hivpopulation.read_resistance_coefficients = new_instancemethod(_FFPopSim.hivpopulation_read_resistance_coefficients,None,hivpopulation)
hivpopulation.write_genotypes = new_instancemethod(_FFPopSim.hivpopulation_write_genotypes,None,hivpopulation)
hivpopulation_swigregister = _FFPopSim.hivpopulation_swigregister
hivpopulation_swigregister(hivpopulation)



